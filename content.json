{"pages":[{"title":"about","text":"-","link":"/about/index.html"}],"posts":[{"title":"BUUCTF web WarmUp总结","text":"题目信息 靶机：http://web5.buuoj.cn 构造的payloadhttp://web5.buuoj.cn/?file=source.php%253f/../../../../ffffllllaaaagggg 基础知识 $_REQUEST empty() isset() is_string() in_array() urldecode() mb_substr() mb_strpos() 资料phpmyadmin 4.8.1 远程文件包含漏洞（CVE-2018-12613） 详细过程一打开链接便是一个坏坏的表情，毫不犹豫地打开邪恶的F12小窗口发现body标签注释source.php。进入看到了一段PHP代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { $whitelist = [\"source\"=&gt;\"source.php\",\"hint\"=&gt;\"hint.php\"]; if (! isset($page) || !is_string($page)) { echo \"you can't see it\"; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo \"you can't see it\"; return false; } } if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; } else { echo \"&lt;br&gt;&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /&gt;\"; } ?&gt; 原来是PHP代码审计，so开始吧。whitelist数组里有另一个元素hint.php，进去看看(感觉不会是flag)。emmm果然 1flag not here, and flag in ffffllllaaaagggg 但是提示了我们flag存储的地方 乖乖返回source.php…代码最后有一段 1234567if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; } 即满足下面的条件就会include $ _REQUEST[‘file’] $ _REQUEST[‘file’]不为空 $ _REQUEST[‘file’]为字符串 emmm::checkFile($_REQUEST[‘file’])返回值为真。 接下来看看emmm::checkFile()这个函数 里面有三个和返回值有关的if语句 传入的$page是否在whitelist里面 在?前面传入的值是否在whitelist里面 在url解码后的值?前面是否在whitelist里面 开始的时候尝试构造?file=source.php无果然后又构造?file=source.php?再次无果最后由于要url解码两次（输入栏解码一次，urldecode()函数解码一次），所以我先构造?file=source.php%253f，想到之前进入hint.php里面有一个提示，但是不知道怎么进如目录，于是乎来一波Google，原来是去年的一个CVEphpmyadmin 4.8.1 远程文件包含漏洞（CVE-2018-12613） so如Writeup开始部分，构造payload得Flag。","link":"/2019/07/22/BUUCTFweb-WarmUp%E6%80%BB%E7%BB%93/"},{"title":"Bigdata learning","text":"- 1. Hadoop环境搭建1.1 安装虚拟机以及Centos操作系统我的组合是VMware16、Centos8和Hadoop2.7.7。建议Centos系统是1个graph模式和2个multi模式。 图形界面和命令行切换： 1234systemctl get-default # 查看目前的启动方式 multi-user是命令行模式，graphical是图形界面模式systemctl set-default graphical.target # 设置为图形界面systemctl set-default multi-user.target # 设置为命令行界面reboot # 重启 如果开始安装的是命令行界面，则还需要安装gnome图形界面。 1234yum groupinstall -y \"Server with GUI\" # 安装图形界面软件包systemctl set-default graphical.targetsystemctl enable gdm --now # 设置图形界面开机自启动reboot # 重启 Centos8右键菜单默认没有打开终端选项，我们可以设置快捷键来启动它 1234567设置 -&gt; 设备 -&gt; display -&gt; keyboard -&gt; 底部添加选项 -&gt; 点击名称: terminal命令: /usr/bin/gnome-terminal快捷键: 自己喜欢的组合键即可，我的是Ctrl+Alt+T 1.2 Hadoop的搭建参考 Hadoop安装教程_单机/伪分布式配置_Hadoop2.6.0(2.7.1)/Ubuntu14.04(16.04) Hadoop集群安装配置教程_Hadoop2.6.0_Ubuntu/CentOS 一般的步骤是 关闭并禁用防火墙 创建hadoop用户 更新yum 安装java环境 安装hadoop并配置 克隆虚拟机 配置网络 修改slave的配置文件 配置ssh免密登录 在master上开启Hadoop 过程中最容易出现的错误是最后两步，如果ssh配置后不行的话，可以试参考 ssh配置authorized_keys后仍然需要输入密码的问题 不过具体问题还得看日志，根据日志来解决问题。 2. 编译运行WordCount程序参考 使用命令行编译打包运行自己的MapReduce程序 Hadoop2.6.0 使用Eclipse编译运行MapReduce程序_Hadoop2.6.0_Ubuntu/CentOS 其中eclipse在Centos下的安装程序链接失效，截止2020.10.04，http://eclipse.bluemix.net/packages/2020-09/data/eclipse-java-2020-09-R-linux-gtk-x86_64.tar.gz 还可以下载。 过程中遇到的问题 Input path does not exist: hdfs://master:9000/user/hadoop/input 123hdfs dfs -mkdir -p /user/hadoophdfs dfs -mkdir input/usr/local/hadoop/bin/hadoop fs -put ./input input There are 0 datanode(s) running and no node(s) are excluded in this operation. 1首先见检查三台机器的网络连接，没有问题的话执行$HADOOP_HOME/sbin/stop-all.sh，关闭Hadoop之后重新启动。 Warn: Unable to load native-hadoop library for your platform… using builtin-java classes where applicable 123在~/.bashrc下加入export JAVA_LIBRAY_PATH=/usr/local/hadoop/lib/native并source ~/.bashrc即可 运行eclipse提示java版本必须在11及以上 123yum安装jdk11alternatives的使用.bashrc的配置 参考 Linux下怎么切换使用两个版本的JDK Failed: java.net.SocketException: Network is unreachable 检查Hadoop集群的网络连接 3. HDFS与Shell命令的交互参考 分布式文件系统HDFS 学习指南 运行HDFSFileIfExist.java时except Connection refused 首先检查/etc/hosts是否有localhost IP映射到hadoop namenode，也可以直接在源代码中修改localhost为namenode的IP。 4. Spark安装与基础使用参考 Spark安装与基础使用 运行spark-shell失败Failed to initialize compiler: object java.lang.Object in compiler mirror not found. 看完报错日志里的 123456error: error while loading package, Missing dependency 'object java.lang.Object in compiler mirror', required by /usr/local/spark/lib/spark-assembly-1.6.0-hadoop2.2.0.jar(scala/package.class)error: error while loading package, Missing dependency 'object java.lang.Object in compiler mirror', required by /usr/local/spark/lib/spark-assembly-1.6.0-hadoop2.2.0.jar(scala/runtime/package.class)** Note that as of 2.8 scala does not assume use of the java classpath.** For the old behavior pass -usejavacp to scala, or if using a Settings** object programatically, settings.usejavacp.value = true. 大概就知道是哪里出错了。 首先检查是否安装Scala，然后java -version检查Java版本，接着查看环境变量里面JAVA_HOME是否是1.8x版本的路径，最后检查 123cd /your/spark/home/vim ./bin/spark-shell# settings.usejavacp.value = true. 5. HBase安装参考 ZooKeeper 和 HBase 官方文档中文版 先安装zookeeper，接着再安装下载hbase包。 有一个步骤一定要注意，就是在配置完成后修改 /hbase/home/conf/hbase-env.sh，找到HBASE_PID_DIR，默认是/tmp文件夹，由于该文件夹下内容非常容易丢失，我们可以按照模板给的/var/hadoop/pids，mkdir -p创建文件夹。不然stop hbase时会出现 No such file or directory问题。 最后安装启动顺序启动即可，即hadoop-&gt;zookeeper-&gt;hbase，关闭顺序反过来即可。 不知道是不是错觉，自带的zoo.cfg配置文件模板不能直接用。 6. TensorFlow环境搭建如果有在线环境可以参考 TensorFlow官网 CentOS安装可能会出现 is not a supported wheel on this platform报错。这时候就需要修改文件名 12import pipprint(pip.pep425tags.get_supported()) 查看python支持的文件名中的字符。 譬如我的python版本是3.6，安装的原名字是tensorflow_cpu-2.3.0-cp36-cp36m-manylinux2010_x86_64.whl，就需要修改为tensorflow-2.3.0-cp36-cp36m-manylinux1_x86_64.whl。 这是去年比赛的答案 Linux安装python3环境使用安装包安装python3.6解压 12345678tar -zxvf Python-3.6.3.tgzcd Python-3.6.3yum -y install zlib* openssl* # 先安装依赖包./configure --prefix=/usr/local/python3 # 指定安装目录，开始安装make &amp; make installln -s /usr/local/python3/bin/python3 /usr/bin/python3 # 建立软连接ln -s /usr/local/python3/bin/pip3 /usr/bin/pippip install tensorflow-1.1.0rc1-cp36-cp36m-manylinux1_x86_64.whl # 使用pip安装tensorflow Demo Configurationhdfs-site.xml 1234567891011121314151617181920212223242526272829&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;3&lt;/value&gt; &lt;description&gt;设置数据块被复制的份数&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;master:50090&lt;/value&gt; &lt;description&gt;辅助namenode的HTTP服务器地址&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;description&gt;namenode存储永久性的元数据的目录列表，逗号分隔file://${hadoop.tmp.dir}/dfs/name&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;description&gt;datanode存放数据块的目录列表file://${hadoop.tmp.dir}/dfs/data&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.max.transfer.threads&lt;/name&gt; &lt;value&gt;4096&lt;/value&gt; &lt;description&gt;在DataNode间传输block数据的最大线程数&lt;/description&gt; &lt;/property&gt; &lt;/property&gt;&lt;/configuration&gt; core-site.xml 12345678910111213&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Hadoop临时文件的文件夹&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;description&gt;默认文件系统，默认端口8020&lt;/description&gt; &lt;/property&gt;&lt;/configuration&gt; yarn-site.xml 1234567891011121314151617&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;master&lt;/value&gt; &lt;description&gt;运行资源管理器的机器主机名&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;description&gt;节点管理器运行的附加服务列表&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;master:8031&lt;/value&gt; &lt;description&gt;资源管理器的resource tracker的RPC服务器地址和端口&lt;/description&gt; &lt;/property&gt;&lt;/configuration&gt; mapred-site.xml 1234567891011121314151617&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;description&gt;possible values which it can take: local, classic , yarn&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;master:10020&lt;/value&gt; &lt;description&gt;作业历史服务器的RPC服务器地址和端口，客户端用于查询作业历史&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;master:19888&lt;/value&gt; &lt;description&gt;MapReduce作业历史服务器地址和端口&lt;/description&gt; &lt;/property&gt;&lt;/configuration&gt; zoo.cfg 12345678tickTime=2000dataDir=/usr/local/zookeeper/dataclientPort=2181initLimit=10syncLimit=4server.1=master:2888:3888server.2=slaver1:2888:3888server.3=slaver2:2888:3888 hbase-site.xml 123456789101112131415&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://master:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;master,slaver1,slaver2&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hbase-env.sh 123export HBASE_PID_DIR=/var/hadoop/pidsexport HBASE_MANAGES_ZK=false","link":"/2020/10/05/Bigdata-learning/"},{"title":"C++ Primer Plus学习简记","text":"新类型 (1) long long和unsigned long long以支持64位+的整型 (2) char16_t和char32_t，用来支持16位和32位的字符表示 初始化两种方式 (1) Type val = { } (2) Type val {} 示例: int x = { 4 }; int y { 5 }; std::initializer_listC++提供一个模板类initializer_list用于构造函数的参数，如果包含头文件initializer_list后，还可将initializer_list用作常规函数的参数。 12345678910111213141516171819202122232425262728293031#include&lt;initializer_list&gt;double sum(std::initializer_list&lt;double&gt; il);int main(){ double total = sum({2.5, 3.1, 4});...}double sum(std::initializer_list&lt;double&gt; il){ double tot = 0; for(auto p = il.begin(); p != il.end(); p++) tot += *p; return tot;} 声明(1) 上面使用了auto关键字，C++将其用于实现自动类型推断，注意: 使用auto关键字必须将变量进行显式初始化。 (2) 关键字decltype将变量的类型声明为表达式指定的类型。 示例: double x; int n; decltype (xn) q; // q的类型同等于xn的类型 decltype (&amp;n) pd; // pd的类型同等于double *类型 (3) 返回类型后置 在函数名和参数列表后指定返回类型。 示例: double f1(double, int); auto f2(double, int) -&gt; double; // 指定返回类型式double (4) 模板别名: using = 对于冗长复杂的标识符一般使用typedef处理，但是对于模板部分初始化，typedef就不可以使用了。这里C++11提供了新的语法 using = 示例: std::array&lt; double, 12 &gt; a1; std::array&lt;std::string, 12&gt; a2; // 可替换为 arr12&lt; double &gt; a1; arr12&lt; std::string &gt; a2; (5) nullptr 空指针，不同于0来表示空指针。 智能指针unique_ptr、shared_ptr和weak_ptr三种。 它们的存在解决了程序不能在对象销毁时自动释放new出来的堆内存仅仅销毁了指针。 对类的修改显式转换运算符explicit禁止单参数构造函数导致的隐式自动转换。 模板和STL方面的修改(1) 基于范围的for循环 for(Type x : y) { … } // 示例 double prices[5] = { 4.99, 10.99, 6.87, 7.99, 8.49}; for(double x : prices) std::cout&lt;&lt; x &lt;&lt; std::endl; (2) 新的STL容器 (3) 新的STL方法 (4) valarray升级 (5) 摒弃export 移动语义和右值引用移动语义存在的原因：程序中的某些类使用动态内存分配，为了初始化对象，复制构造函数将使用new给对象分配内存，如果对象需要的内存很大，会导致内存从一处分配到另一处的工作量很大。所以就需要移动语义来避免移动原始数据，仅修改标记那片内存的标志即可。 右值引用: 123456789101112131415// 假设有一个Useless类，并且都有其相应的构造函数Useless one;Useless two;Useless three (one + two);// 并且有两个构造函数Useless::Useless(const Useless &amp;); // 左值引用构造函数Useless::Useless(Useless &amp;&amp;); // 右值引用构造函数表达式 one+two 调用Useless::operator+()，右值引用将关联到该构造方法返回的临时对象。即Useless Useless::operator+(const Useless &amp; f) const{ Useless temp = Useless(n+f.n); for(int i = 0; i &lt; n; i++) temp.pc[i] = pc[i]; for(int i = n; i &lt; temp.n; i++) temp.pc[i] = f.pc[i - n]; return temp;} 因为one是左值，与左值引用匹配，而表达式one+two是右值，与右值引用匹配。因此右值引用让编译器使用移动构造函数来初始化对象three。 通过提供一个左值引用的构造函数和一个使用右值引用的构造函数，将初始化分成两组，左值初始化对象使用复制构造函数，右值对象初始化使用移动构造函数。 移动构造和移动赋值函数运算符使用右值，如果要让它们使用左值，可以使用移动构造函数或移动赋值运算符来保留选定的对象。例如 12345Useless choices[10];Useless best;int pick;// 设置pick变量为数组的索引best = choices[pick]; choices[pick]是左值，因此使用复制赋值运算符。如果能让其看起来像右值，就可以使用移动赋值运算符对其进行操作。C++提供了一个解决方案，运算符static_cast&lt;&gt;，将对象类型强制转换为Useless &amp;&amp;，到了C++11，我们有一种更简单的方式-使用头文件utility中声明的函数std::move()。 新的类功能特殊的成员函数特殊的成员函数有默认构造函数，复制构造函数，复制赋值运算符析构函数，移动构造函数和移动赋值函数6个。这些成员函数是编译器在各种情况下自动提供的。 C++使用default和delete关键字让coder可以更好地控制要使用地方法。 123456789class Someclass{public: Someclass(Someclass &amp;&amp;) =default; Someclass() = default; Someclass(const Someclass &amp;) = delete; Someclass &amp; operator=(const Someclass &amp;) = default;...}; 上述就是它们的使用方法，default关键字显式地声明这些方法的默认版本，delete关键字用于禁止编译器使用特定方法。其中，要禁止复制，可将复制构造函数和赋值运算符放在类定义的private部分，但是delete这种方法更容易理解且不容易出错。而且default只能用于6个特殊成员函数，delete可用于任何成员函数。 管理虚方法override和final虚方法对实现多态层次结构很重要，让基类引用或指针能根据指向的对象类型调用相应的方法。 假设有一个基类Action以及它的一个Bingo派生类，其中有同名的虚函数 12virtual f(char ch); // class Actionvirtual f(char *ch); // class Bingo 上述代码将对Bingo对象隐藏f(char ch)，导致程序不能使用Action类下的f()。C++11提供了override说明符，用于指出要覆盖的一个虚函数。如果想禁止派生类覆盖特定的虚方法可以使用final说明符。 1234virtual void f(char * ch) const override { std::cout &lt;&lt; val() &lt;&lt; ch &lt;&lt; \"!\\n\"; }virtual void f(char ch) const final { std::cout &lt;&lt; val() &lt;&lt; ch &lt;&lt; \"!\\n\"; } Lambda函数简而言之，lambda函数的意义是为了简化函数符代码。 示例: 1234567count1 = std::count_if(n1.begin(),n1.end(), [] (int x) { return x % 3 == 0;} );count2 = std::count_if(n2.begin(),n2.end(), [] (int x) { return x % 3 == 0;} );auto mod3 = [] (int x) { return x % 3 == 0; }count3 = std::count_if(n1.begin(),n1.end(), mod3);count4 = std::count_if(n2.begin(),n2.end(), mod3); 由于lambda可以访问作用域内的任何动态变量，[z]按值访问变量，[&amp;count]按引用访问变量。[&amp;]按引用访问所有的动态变量，[=]按值访问所有动态变量。[ted, &amp;ed]按值访问ted以及按引用访问ed，[&amp;, ted]能够按值访问ted以及按引用访问其他所有的动态变量，[=, &amp;ed]按引用访问ed以及按值访问其他所有动态变量。 也可以像下面这样 12345678int count13;...count13 = std::count_if(numbers.begin(), numbers.end(), [] (int x) { return x % 13 == 0; });// 替换为int count13 = 0;std::for_each(numbers.begin(), numbers.end(), [&amp;count13] (int x) { count13 += x % 13 ==0; }); 包装器C++提供了多个包装器(wrapper，也叫适配器[adapter])。这些对象用于给其他编程接口提供更一致或更合适的接口。 包装器function就是其中之一。模板function在头文件functional中声明的，它可用包装调用特征标相同的函数指针、函数对象或lambda表达式。 1std::function&lt;Type(Type1, Type2)&gt; var; 可变参数模板 模板参数包(paramrter pack) 函数参数包 展开(unpack)参数包 递归 12template&lt;typename... Args&gt;void show_list1(Args... arg) { ... } Args是一个模板参数包，而args是一个函数参数包。可将参数包的名称指定为任意符合C++表示符规则的名称。Args于模板T区别是Args与任意数量的类型匹配，T只与一种类型匹配。 例如void show_list1(‘S’, 80, “sweet”, 4.5);由于Args参数包展开是递归展开的，由于函数调用与原始函数调用相同，它将导致无限递归。 其中之一的解决方案是 12template&lt;typename T, typename... Args&gt;void show_list3(T value, Args... args)","link":"/2020/08/25/C++%20Primer%20Plus%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0/"},{"title":"CTFd搭建及优化笔记","text":"由于最近学校要办校赛，需要一个平台作为考核点，我选择的平台是CTFd。网上大多数搭建是个人的或者放在公网上的，记录一下我自己的搭建过程。（局域网 我的环境是CentOS7+虚拟机 设置静态IP安装、设置环境12yum updateyum install -y git nginx mariadb mariadb-server Mysql-python python-pip gcc python-devel yum-utils device-mapper-persistent-data lvm2 epel-release 安装mysql123mysql_secure_installation都是选择yyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装docker1234yum -y install docker-ce-17.12.1.cecurl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io # DaoCloud配置docker镜像源加速docker --version # 检查安装是否成功systemctl start docker # 启动 安装docker-compose下面有两种方法安装 直接下载 12345678# 下载docker composecurl -L \"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose# 添加可执行权限chmod +x /usr/local/bin/docker-compose# 将文件copy到 /usr/bin/目录下ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose# 查看版本docker-compose --version pip安装，安装python3和python3-pip 123pip3 install docker-composedocker-compose --versionchmod +x /usr/local/bin/docker-compose 安装frp12345678910111213cdwget https://github.com/fatedier/frp/releases/download/v0.29.0/frp_0.29.0_linux_amd64.tar.gztar -zxvf frp_0.29.0_linux_amd64.tar.gzcd frp_0.29.0_linux_amd64cp systemd/* /etc/systemd/system/mkdir /etc/frpcp frpc.ini frps.ini /etc/frp/cp frpc frps /usr/bin/chmod a+x /usr/bin/frpc /usr/bin/frpssystemctl enable frps# 配置frps.ini文件vim /etc/frp/frps.inisystemctl start frps 12345# frps.ini[common]bind_port = 7897bind_addr = 0.0.0.0token =thisistoken 配置docker镜像加速1mkdir -p /etc/docker 参考https://cr.console.aliyun.com/cn-beijing/instances/mirrors 配置镜像加速。 1vim /etc/frp/frpc.ini 1234[common]server_addr = 172.17.0.1 # 为主机ifconfig的docker0网卡的ipserver_port = 7897token=thisistoken 修改~/frp_0.29.0_linux_amd64/frpc.ini 1vim ~/frp_0.29.0_linux_amd64/frpc.ini 1234567[common]server_addr = 172.17.0.1 # 这里填写宿主机ifconfig之后docker0的ipserver_port = 7897token=thisistokenadmin_addr = 172.19.0.2 #这里填写frpc容器在frpcadmin网络里的ipadmin_port = 7400log_file = ./frps.log 12docker network create ctfd_frp-containersdocker run -d -v ~/frp_0.29.0_linux_amd64/frpc.ini:/etc/frp/frpc.ini --network=\"ctfd_frp-containers\" --restart=always \"glzjin/frp\" 1234docker network create frpcadmin docker network connect frpcadmin id # id是&lt;frpc容器名或者ID&gt; # 将frpc和ctfd容器单独连接到网络frpcadmin,注意要等容器创建好之后再连接，因此ctfd将在稍后连接docker network inspect frpcadmin 下载安装CTFd和CTFd-whale插件12345678910git clone https://github.com/CTFd/CTFd.gitcd CTFd/git reset 6c5c63d667a17aec159c8e26ea53dccfbc4d0fa3 --hard# 回滚到当前教程适合的版本cd CTFd/plugins #打开ctfd插件目录git clone https://github.com/glzjin/CTFd-Whale.git ctfd-whale #确保插件文件夹小写cd ctfd-whalegit reset 5b32f457e9f56ee9b2b29495f4b3b118be3c57bd --hard # 回滚到当前教程适合的版本cd ../.. # 返回ctfd主目录vim docker-compose.yml 修改docker-compose.ini文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455version: '2.2'services: ctfd: build: . user: root restart: always ports: - \"8000:8000\" # 第一个是访问ctfd的端口，第二个是docker端口映射出去的端口 environment: - UPLOAD_FOLDER=/var/uploads - DATABASE_URL=mysql+pymysql://root:ctfd@db/ctfd - REDIS_URL=redis://cache:6379 - WORKERS=1 - LOG_FOLDER=/var/log/CTFd - ACCESS_LOG=- - ERROR_LOG=- volumes: - .data/CTFd/logs:/var/log/CTFd - .data/CTFd/uploads:/var/uploads - .:/opt/CTFd:ro - /var/run/docker.sock:/var/run/docker.sock # 添加这句即可，别的基本按照官方的不用动 depends_on: - db networks: default: internal: db: image: mariadb:10.4.12 #这里改成10.4.12，10.4.13会出错 restart: always environment: - MYSQL_ROOT_PASSWORD=ctfd - MYSQL_USER=ctfd - MYSQL_PASSWORD=ctfd - MYSQL_DATABASE=ctfd volumes: - .data/mysql:/var/lib/mysql networks: internal: # This command is required to set important mariadb defaults command: [mysqld, --character-set-server=utf8mb4, --collation-server=utf8mb4_unicode_ci, --wait_timeout=28800, --log-warnings=0] cache: image: redis:4 restart: always volumes: - .data/redis:/data networks: internal:networks: default: internal: internal: true 修改Dockerfile文件1vim Dockerfile 1234567891011121314151617181920212223FROM python:2.7-alpineRUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories &amp;&amp;\\ apk update &amp;&amp; \\ apk add python python-dev linux-headers libffi-dev gcc make musl-dev py-pip mysql-client git openssl-devRUN adduser -D -u 1001 -s /bin/bash ctfdWORKDIR /opt/CTFdRUN mkdir -p /opt/CTFd /var/log/CTFd /var/uploadsRUN pip config set global.index-url https://pypi.doubanio.com/simpleRUN pip config set install.trusted-host pypi.doubanio.comCOPY requirements.txt .RUN pip install -r requirements.txt -i https://pypi.doubanio.com/simpleCOPY . /opt/CTFdRUN for d in CTFd/plugins/*; do \\ if [ -f \"$d/requirements.txt\" ]; then \\ pip install -r $d/requirements.txt -i https://pypi.doubanio.com/simple; \\ fi; \\ done;RUN chmod +x /opt/CTFd/docker-entrypoint.shRUN chown -R 1001:1001 /opt/CTFdRUN chown -R 1001:1001 /var/log/CTFd /var/uploadsUSER 1001EXPOSE 8000ENTRYPOINT [\"/opt/CTFd/docker-entrypoint.sh\"] 在CTFd目录下找到requirements.txt并添加 banal==0.4.212docker-compose builddocker-compose up -d 连接frpcadmin网络123docker ps -a # 查看ctfd的iddocker network connect frpcadmin &lt;id&gt;docker network inspect frpcadmin # 检查是否成功 然后访问ip:8000即可。 配置动态flag参考 CTFd-Whale 推荐部署实践 手把手教你如何建立一个支持ctf动态独立靶机的靶场 优化访问速度将CTFd\\themes\\core\\static\\css\\vendor\\font-awesome 目录下的fontawesome-fonts.css文件替换为https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css ，重启docker。","link":"/2020/10/30/CTFd%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/"},{"title":"Data analysis","text":"常用的统计图 折线图: 折线的上升或者下降表示统计数量的增减变化的统计图。（变化） 直方图: 一系列高低不等的纵向条纹或线段表示数据分布情况。（统计） 条形图: 排列在工作表的列或行中的数据可以绘制到条形图中。（统计） 散点图: 多个坐标点，考察坐标点分布，判断变量之间是否存在某种关联。（分布规律） Python可视化依赖的库matplotlib 12345678910111213141516171819202122232425262728293031323334from matplotlib import pyplot as pltplt.rcParams['font.sans-serif'] = ['SimHei'] # 指定默认字体：解决plot不能显示中文问题plt.rcParams['axes.unicode_minus'] = False # 解决保存图像是负号'-'显示为方块的问题plt.figure(figsize=(20, 8), dpi=80) # 调用figure实例设置图片大小 dpi参数让图片更清晰# 绘制折线图，有几条调用几次plot方法。plt.plot(x, y, # x、y表示在x轴和y轴的数据 label='图例名称', # 设置图例名称 linestyle='-', # 设置图线的风格 color='purple', # 设置图线的颜色 alpha=0.3) # 设置图线透明度# ...# plt.plot(x, y)label_x = list[x轴的描述信息]plt.xticks(list[x], # 设置x轴的刻度 list[x][::2]兼容步长 label_x, # 设置x轴的标签 ratotion=90) # 设置旋转的度数label_y = list[y轴的描述信息]plt.yticks(list[y], label_y) # 设置y轴的刻度以及标签plt.xlabel('添加x轴的表示信息')plt.ylabel('添加y轴的表示信息')plt.title('标题')plt.grid(alpha=0.3) # 添加网格并设置透明度plt.legend('添加图例') # 对应plot()方法中的label参数，解释线段表示的内容plt.savefig('name.png') # 保存图片到本地plt.show() # 画出图形 123456789101112# 几种图例的方法# 折线图plt.plot()# 散点图plt.scatter(x, y)# 条形图plt.bar(list[x], width='线条宽度')# 直方图# hist方法是用于没有被统计过的数据plt.hist(a, # a为需要统计的数据 num_bins, # num_bins为分组的组数 normed=1) # normal参数为是否绘制频率分布直方图，默认为频数直方图 numpy定义是一个Python中做科学计算的基础库，重在数值计算，多用于大型、多维数组上执行数值运算。 使用123456789101112import numpy as np# 三种创建数组的方法 [1, 2, 3, 4, 5]a = np.array([1, 2, 3, 4, 5])b = np.array(range(1, 6))c = np.arange(1, 6)print(type(a)) # 返回a的数据结构类型print(a.dtype) # dtype返回数据元素的数据类型 必须是同一数据类型print(a.astype(np.float)) # 返回临时修改的数据类型的数组b = np.array([0.048, 0.266])print(np.round(b,2)) # 设置b的输出格式为保留两位小数 形状123456789import numpy as npa = np.array([[3, 4, 5, 6, 7, 8], [4, 5, 6, 7, 8, 9]])print(a.shape) # (2, 6)a.reshape(3, 4)print(a) # [[3, 4, 5, 6, 7, 8], [4, 5, 6, 7, 8, 9]]a = a.reshape(3, 4)print(a) # [[3 4 5 6] [7 8 4 5] [6 7 8 9]] 这里的a和第三行的a不是同一个aprint(a.flatten()) # array([3, 4, 5, 6, 7, 8, 4, 5, 6, 7, 8, 9]) 计算123456789101112131415161718import numpy as npa = np.array([[3, 4, 5, 6, 7, 8], [4, 5, 6, 7, 8, 9]])print(a)a = a + 1print(a)a = a * 3print(a)# 运行结果\"\"\"[[3 4 5 6 7 8] [4 5 6 7 8 9]][[ 4 5 6 7 8 9] [ 5 6 7 8 9 10]][[12 15 18 21 24 27] [15 18 21 24 27 30]] \"\"\" 上述的能够正确计算是因为numpy的广播机制。 大致意思是 维度相同，其中一方轴长度为1 例如shape为(3,3)和(3,1)的数组能够进行计算。 123456789101112import numpy as npa = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])b = np.array([[1], [2], [3]])print(a + b)# 运行结果\"\"\"[[ 2 3 4] [ 6 7 8] [10 11 12]]\"\"\" 维度不同，后缘维度的轴长度相同 例如shape为(3,3,2)和(3,2)的数组能够进行计算。 1234567891011121314151617181920import numpy as npa = np.array([[[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4], [5, 6]]])b = np.array([[1, 2], [3, 4], [5, 6]])print(a+b)# 运行结果\"\"\"[[[ 2 4] [ 6 8] [10 12]] [[ 2 4] [ 6 8] [10 12]] [[ 2 4] [ 6 8] [10 12]]]\"\"\" 使用numpy读取数据12345678910111213141516171819202122232425262728293031323334loadtxt(fname, dtype=float, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding='bytes', max_rows=None)\"\"\"fname: 文件、字符串或产生器，支持.gz或bz2压缩文件dtype: 数据类型，默认np.floatdelimiter: 读取数据的分隔字符串，默认空格skiprows: 跳过读取前x行usecols: 读取指定的列，索引，元组类型unpack: 讲数据写入数组变量，False只写入一个数组变量，True可写入不同的数组变量\"\"\"# 基本使用案例import numpy as np&gt;&gt;&gt; from io import StringIO # StringIO behaves like a file object&gt;&gt;&gt; c = StringIO(u\"0 1\\\\n2 3\")&gt;&gt;&gt; np.loadtxt(c)array([[0., 1.], [2., 3.]])&gt;&gt;&gt; d = StringIO(u\"M 21 72\\\\nF 35 58\")&gt;&gt;&gt; np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'), ... 'formats': ('S1', 'i4', 'f4')})array([(b'M', 21, 72.), (b'F', 35, 58.)], dtype=[('gender', 'S1'), ('age', '&lt;i4'), ('weight', '&lt;f4')])&gt;&gt;&gt; c = StringIO(u\"1,0,2\\\\n3,0,4\")&gt;&gt;&gt; x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)&gt;&gt;&gt; xarray([1., 3.])&gt;&gt;&gt; yarray([2., 4.]) numpy索引和切片1234567891011import numpy as npa = np.array([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]])print(a[1]) # 取第二行 [4 5 6 7]print(a[:, 2]) # 取第三列 [ 2 6 10]print(a[1:3]) # 取第二行和第三行 [[ 4 5 6 7] [ 8 9 10 11]]print(a[:, 2:4]) # 取第三列和第四列 [[ 2 3] [ 6 7] [10 11]]# bool索引替换数字a[:, 2:4] = 0 # [[0 1 0 0] [4 5 0 0] [8 9 0 0]]a[a &lt; 4] = -1 # [[-1 -1 -1 -1] [ 4 5 6 7] [ 8 9 10 11]] numpy三元运算符123456789101112131415161718import numpy as npt = np.arange(24).reshape((4, 6))print(np.where(t &lt; 10, 0, 10)) # 小于10的替换为0，否则替换为10\"\"\"[[ 0 0 0 0 0 0] [ 0 0 0 0 10 10] [10 10 10 10 10 10] [10 10 10 10 10 10]]\"\"\"\"\"\"If all the arrays are 1-D, `where` is equivalent to:: [xv if c else yv for c, xv, yv in zip(condition, x, y)]\"\"\" numpy中的裁剪clip123456789101112131415161718192021import numpy as npt = np.arange(24).reshape((4, 6))print(t.clip(10, 18)) # 小于10的替换为10，大于18的替换为18t = t.astype(float) # 数组转换为float类型t[3, 3], t[3, 4], t[3, 5] = np.nan, np.nan, np.nanprint(t.clip(10, 18))# 运行结果\"\"\"[[10 10 10 10 10 10] [10 10 10 10 10 11] [12 13 14 15 16 17] [18 18 18 18 18 18]] [[10. 10. 10. 10. 10. 10.] [10. 10. 10. 10. 10. 11.] [12. 13. 14. 15. 16. 17.] [18. 18. 18. nan nan nan]]\"\"\" 关于nan和inf nan(NAN, Nan): not a number 出现nan的条件：首先数据为float并且有缺失的时候，其次就是做了一个不合适的计算的时候。 inf(-inf, +inf): 无穷大 出现inf的条件：1个数字除以0。 12345678# nan的注意点# np.nan != np.nan# 利用# 判断数组中nan的个数np.count_nonzero(t != t)# 把nan替换为0t[np.isnan(t)] = 0# nan和任何值计算都为nan 注意： ==如果把缺失值nan替换为0后，会影响整个数据的均值，所以一般的操作是把缺失的数值替换为均值或者直接删除缺失值的一行。== numpy中常用的统计函数1234567t.sum() # 求和t.mean() # 求均值np.median(t) # 求中值t.max() # 求最大值t.min() # 求最小值np.ptp(t) # 求极值 最大值和最小值之差t.std() # 求标准差 值越大越不稳定 上述函数都是默认返回多维数组的全部统计结果，如果加上参数axis并指定值，则返回指定轴上的结果。 ndarry缺失值填充均值1234567891011121314151617181920212223242526import numpy as npt = np.arange(24).reshape((4, 6))t = t.astype(float)t[1, 2], t[2, 3] = np.nan, np.nandef fill_nan_by_column_mean(t): for i in range(t.shape[1]): nan_num = np.count_nonzero(t[:, i][t[:, i] != t[:, i]]) # 计算非nan的个数 if nan_num &gt; 0: now_col = t[:, i] now_col_not_nan = now_col[np.isnan(now_col) == False].sum() now_col_mean = now_col_not_nan / (t.shape[0] - nan_num) now_col[np.isnan(now_col)] = now_col_mean t[:, i] = now_colfill_nan_by_column_mean(t)print(t)\"\"\"[[ 0. 1. 2. 3. 4. 5.] [ 6. 7. 12. 9. 10. 11.] [12. 13. 14. 11. 16. 17.] [18. 19. 20. 21. 22. 23.]]\"\"\" 数组的拼接123456789101112131415161718# 数组拼接前应注意每列代表的意义相同import numpy as npt1 = np.arange(12).reshape((2, 6))t2 = np.arange(12, 24).reshape((2, 6))print(np.vstack((t1, t2))) # vertically 竖直拼接print(np.hstack((t1, t2))) # horizontally 水平拼接\"\"\"[[ 0 1 2 3 4 5] [ 6 7 8 9 10 11] [12 13 14 15 16 17] [18 19 20 21 22 23]] [[ 0 1 2 3 4 5 12 13 14 15 16 17] [ 6 7 8 9 10 11 18 19 20 21 22 23]]\"\"\" 数组的行列交换12t[[1, 2], : ] = t[[2, 1], : ] # 行交换 第二行和第三行交换t[:, [0, 2]] = t[:, [2, 0]] # 列交换 第一列和第三列交换 numpy更多的方法12345np.argmax(t, axis=0) # 获取最大值的位置np.argmin(t, axis=1) # 获取最小值的位置np.zeros((3, 4)) # 创建一个全0的数组np.ones((3, 4)) # 创建一个全1的数组np.eye(3) # 创建一个对角线为1的正方形数组 numpy的copy和view a = b完全不复制，a和b相互影响。因为他们同在一个内存单元。 a = b[:] 视图的操作，创建新的对象a，a的数据完全由b保管，数据的变化是一致的。 a = b.copy() 复制，a和b相互不影响。 pandaspandas除了能帮numpy处理数值，还能处理其他类型的数据。 Series一维带标签数组 DataFrame二维Series容器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import numpy as npimport pandas as pdimport stringt = pd.Series(np.arange(10), index=list(string.ascii_uppercase[:10]))print(t)print(type(t))\"\"\"A 0B 1C 2D 3E 4F 5G 6H 7I 8J 9dtype: int32&lt;class 'pandas.core.series.Series'&gt;\"\"\"a = {string.ascii_uppercase[i]: i for i in range(10)}print(a)print(pd.Series(a))a = pd.Series(a, index=list(string.ascii_uppercase[5:15]))print(a)\"\"\"{'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6, 'H': 7, 'I': 8, 'J': 9}A 0B 1C 2D 3E 4F 5G 6H 7I 8J 9\"\"\"t = t.astype('int32')print(t.dtypes)\"\"\"F 5.0G 6.0H 7.0I 8.0J 9.0K NaNL NaNM NaNN NaNO NaNdtype: float64dtype: int64int32\"\"\" pandas读取外部数据123456789101112import pandas as pdt = pd.DataFrame(np.arange(12).reshape((3,4)))print(t)# 运行结果\"\"\"A 0B 1C 2D 3\"\"\" 上述数据的类型为DataFrame 横向索引叫index，是行索引；纵向索引叫columns，是列索引。 1. DataFrame和Series的关系1234567891011# DataFrame的基础属性df.shape # df的形状。行数、列数df.dtypes # 列数据类型df.ndim # 数据维度df.index # 行索引df.columns # 列索引df.values # 对象值df.head(3) # 头部3行，默认为5df.tail(3) # 尾部3行，默认为5df.info() # 展示相关信息df.describe() # 快速综合统计结果 2. DataFrame对传入数据的类型要求3. 可以对DataFrame进行的数据操作","link":"/2020/10/23/Data-analysis/"},{"title":"Failed to start php-fpm.service: Unit php-fpm.service not found.","text":"今天准备用PHP环境的时候，提示 Failed to start php-fpm.service: Unit php-fpm.service not found.。 systemctl status-all之后，没有找到PHP相关的服务，遂Google一波，解决了。先把博主的这篇博客CtrlV至此https://blog.meathill.com/tech/serverside/failed-to-start-php-fpm-service-unit-php-fpm-service-is-masked.html 正题，很简单，我的php-fpm没装，那就来吧，apt install php-fpm 安装结束后它会自动映射PHP版本。 大功告成，接下来systemctl start php7.3-fpm就可以安心享用了。","link":"/2019/08/06/Failed_to_start_php_fpm_service_Unit_php_fpm_service_not_found/"},{"title":"HTTP协议之HTTP请求和响应","text":"在HTTP连接中报文分为请求（request）和响应（response）两种。每种报文在HTTP首部都有不同的字段来标识不同的用途。 HTTP请求包括请求行，请求头，请求正文HTTP响应包括响应行，响应头，响应正文 请求(Request)HTTP协议中共定义了一些方法来表明对Request-URI指定的资源的不同操作方式。1. GET： 请求指定的页面信息，并返回实体主体。 2. HEAD： 只请求页面的首部。 3. POST： 请求服务器接受所指定的文档作为对所标识的URI的新的从属实体。 4. PUT： 从客户端向服务器传送的数据取代指定的文档的内容。 5. DELETE： 请求服务器删除指定的页面。 6. OPTIONS： 允许客户端查看服务器的性能。 7. TRACE： 请求服务器在响应中的实体主体部分返回所得到的内容。 8. CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 9. PATCH： 实体中包含一个表，表中说明与该URI所表示的原内容的区别。 10. MOVE： 请求服务器将指定的页面移至另一个网络地址。 11. COPY： 请求服务器将指定的页面拷贝至另一个网络地址。 12. LINK： 请求服务器建立链接关系。 13. UNLINK： 断开链接关系。 14. WRAPPED： 允许客户端发送经过封装的请求。 15. Extension-mothed：在不改动协议的前提下，可增加另外的方法。 在实际应用中常用的也就是get和post，其他请求方式也都可以通过这两种方式间接的来实现。 简单的请求报文GET /index.html HTTP/1.1 Accept: text/plain /*纯ASCII码文本文件*/ Accept: text/html /*HTML文本文件*/ User-Agent:Mozilla/4.5(WinNT) 说明浏览器使用Get方法请求文档/index.html。浏览器则只允许接收纯ASCII码文本文件和HTML文本文件，其使用的引擎是Mozilla/4.5（Netscape）。 响应(Response)当服务器响应时，其状态行的信息为HTTP的版本号，状态码，及解释状态码。5种状态码：1. 客户方错误 100 继续 101 交换协议 2. 成功 200 OK 201 已创建 202 接收 203 非认证信息 204 无内容 205 重置内容 206 部分内容 3. 重定向 300 多路选择 301 永久转移 302 暂时转移 303 参见其它 304 未修改（Not Modified） 305 使用代理 4. 客户方错误 400 错误请求（Bad Request） 401 未认证 402 需要付费 403 禁止（Forbidden） 404 未找到（Not Found） 405 方法不允许 406 不接受 407 需要代理认证 408 请求超时 409 冲突 410 失败 411 需要长度 412 条件失败 413 请求实体太大 414 请求URI太长 415 不支持媒体类型 5. 服务器错误 500 服务器内部错误 501 未实现（Not Implemented） 502 网关失败 504 网关超时 505 HTTP版本不支持 简单的响应报文HTTP/1.1 501 Method Not Implemented (状态行) Server: Apache/1.3.12 /*Web服务器信息*/ Connect-Type: Text/html; charset=iso-8859-1/*连接的媒体类型*/ Allow: GET, HEAD, OPTION, TRACE /*支持的方法类型*/ Connection: close Date: Web, 01 Nov 2000 07:12:29 GMT /*当前的日期/时间*/ 更多的头属性参考HTTP头信息总结 闲谈何为URIUniform Resource Identifier，统一资源标识符。Wikipedia给它的定义是：A URI reference is either a URI, or a relative reference when it does not begin with a scheme component followed by a colon (:).如果URI引用不是以scheme组件开头，后跟冒号(:),那么它就是URI，或者是相对引用。简单来说就是在某一规则下标识一个资源。 具体参考：Wiki：URI 和常说的URL有何区别？URL(Uniform Resource Locator，统一资源定位符)。 Wikipedia给它的定义是：A URL implies the means to access an indicated resource and is denoted by a protocol or an access mechanism.URL表示访问指定资源的方法，并由协议或访问机制表示。是一种具体的URI，不仅标识一个资源，还指明如何找到这个资源。 具体参考：Wiki：URL URI = scheme:[[userinfo@]host[:port]]path[?query][#fragment]URL = http://www.example.com www.example.com不是URL 例如：http://www.127.0.0.1:80/example/example.html 整体是一个URL，而/example/example.html是URI引用。 Locators are also identifiers, so every URL is also a URI, but there are URIs which are not URLs.","link":"/2019/08/05/HTTP%E5%8D%8F%E8%AE%AE%E4%B9%8BHTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/"},{"title":"Giving myself the second PEE","text":"- 😭😭血崩地开始二战，本文写给自己以便及时提醒自己！ 不要刻意去推进度，一切以学习效果为核心。慢就是快。只有经过自己真正总结出来的东西，才是属于自己的。计划zz书拿到了有时间瞅两眼，记住只要当天看了视频，就把对应的1000题刷一遍然后做标记。 英语 单词一定要每天背（每天新词150。 暑假开始只看阅读，每天1篇，看陈的视频，生词、重要的语法点、文章结构、上下文的替换、行文逻辑，每天和单词一起背诵复习。 做完之后，对照视频，对比揣摩，看自己差在哪里，哪些地方处理的不够到位，然后总结，找个小本子记下来。有时间就瞟一眼。翻译就… 7-9月： 7.1开始做真题： 05-12 阅读 + 陈仲凯的课 05-12 完型 + 新题型 + 陈仲凯的课 13-19 阅读 + 陈仲凯的课 13-19 完型 + 新题型 + 陈仲凯的课 10月 – 考前： 阅读：复习之前的重点文章 作文：老周 阅读的方法 如何做精读 确定精读材料。粗读一遍，不查字典。用自己感觉最舒适的速度，从头到尾把文章读一遍，标注出不懂的地方（生词、句子等）。不查字典，不回读，不朗读出声。培养良好的阅读习惯，并逐步提高阅读速度。 逐句阅读，死磕每一个单词。对于每个有疑问的地方，都不要放过。一定要注意熟词生义！如果一句话每个单词都认识，读起来感觉不对头，多半是有些你熟悉的单词，在这句话里有你不知道的意思。或者是因为句中有些词组你没有识别出来。这时候，一定要多查字典。查完字典还不懂，那就去提问吧。 笔记整理。全文精读完毕之后，把所有语言点整理复习一遍。 重读原文。再慢速读一遍原文，阅读过程中，仔细回想之前学习过的语言点。 复习回顾。隔几天复习回顾一下笔记，然后再重读文章。 三、重中之重：复习、巩固、输出练习 精读非常耗费心神，而且一定要定期复习。一般来说，一篇文章精读完成后，一定要在一个月内复习回顾2-3遍。因此一定要做好学习和复习的计划安排。 此外，精读要和泛读结合起来。通过大量泛读，也可以巩固精读所学。 另一种巩固方法是写作。可以仿写句子，也可以写阅读笔记等。在写作时有意识地运用最近精读所掌握的句式词汇，从而加深印象。 泛读的注意事项 关注内容。学习语言的目标，是能够获取信息。 由慢到快。刚开始泛读的时候，可能会比较慢。不要着急，哪怕一个词一个词地看，只要能看懂，就坚持看下去。看得多了，速度自然会提起来。 不要动嘴。这个刚开始会有点难度，如果你发现读书的时候嘴唇在动，请立即闭嘴。用脑读，不要用嘴读，因为后者会拖慢阅读速度。 不要回读。碰到不懂的句子和单词，根据你脑海中的已知信息，推断一下是什么意思。实在不懂就跳过去。一两句话看不懂，不会影响整篇文章的大意理解。如果读到后面忘了前面，没关系，继续往后读。专注后面的内容，脑补前面的内容。 偶尔标记一两个单词。偶尔碰到一两个特别好的单词，或者特别影响理解的单词，标记出来。读完之后，再查查字典。 每天坚持。哪怕再忙，也要抽时间读15分钟。空闲的时候，可以读一到两个小时。 [1] 基础薄弱的怎么复习考研英语一？ - 甲巳迁的回答 - 知乎 https://www.zhihu.com/question/318653806/answer/643378285[2] 考研英语如何考到 80 分？ - 日天不吃糖的回答 - 知乎 https://www.zhihu.com/question/26517009/answer/1752767388数学前期积累新技巧+中期熟练使用你擅长的老技巧来解决新问题+后期巩固常规题型的固定技巧 拿来一个题你至少有一个自己很熟练的技巧，形成自己的风格。 李正元全书看一章节内容，做里面的题目（标记做不出来的，方便后续刷），做笔记（核心思想），实在不懂的看视频（视频中间暂停思考，在纸上划划，视频做例题前自己先做一下）。 刷880+108，先标记不会做的去找全书对应内容，然后再在纸上写一遍完整解题步骤，理解透彻。 有时间看看毛纲源的书（增加见识）。 ☆为重点关注的，⭕为有错的，二刷对了打个√。 9月前： 前面的工作做好 9月到10月： 复习一遍全书知识点+近十年真题，主要是定理公式、解题技巧。 10月到考前： 暑期刷的有标记的题+真题错题+做适量的模拟卷 考前几天多总结总结 每个月做一次规划，然后针对这个规划选这个月做什么题，月底看看选这本题的目的实现了没。没实现就去想想问题出在哪。不要一门心思抓住一套题像信仰一样。 [1] 什么时候开始准备考研最合适？怎么做时间安排？ - 日天不吃糖的回答 - 知乎 https://www.zhihu.com/question/20063696/answer/1076511672[2] 经历过2021考研数学后，前辈们给22考研数学复习提出什么样的建议？ - 不觉的回答 - 知乎 https://www.zhihu.com/question/436694500/answer/1661046443专业课八月前看看能不能先过一遍书本＋王道。 看谢老的书外加刷王道，数据结构与算法每日可以刷一题leetcode或者1800。 有时间看看计算机网络释疑解答。 7月底前争取过一轮基础，吃透教材、王道，掌握解题方法。 7月下至8月下 二刷王道，中间穿插复习书本知识点。 9月至10月下 第二轮强化，真题卷子，反复琢磨，争取随便挑一道题都能做对。 11月到考研 第三轮冲刺，查漏补缺，多看教材和自己的笔记，基础细小的知识点很重要 。 Tips 不要熬夜导致第二天起得晚，晚上熬一小时等于白天睡两小时。 套路化的东西不值钱。 要做笔记，先别急着做题，对于整个框架一定要搞清晰，搞清楚重点考点。做的笔记不是摆设，一定要重复看笔记。 弄几张A4纸，每次遇到模糊不清楚的，或者感觉是弱点的，都分类记下来。 [1] 哪些问题是考研前不知道考研后才知道的？ - 空心菜啊的回答 - 知乎 https://www.zhihu.com/question/269429538/answer/415270495","link":"/2022/05/23/Giving-myself-the-second-PEE/"},{"title":"PNG文件头","text":"PNG文件头 （固定）八个字节89 50 4E 47 0D 0A 1A 0A为png的文件头 （固定）四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13 （固定）四个字节49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示（IDCH） （可变）13位数据块（IHDR) 前四个字节代表该图片的宽 后四个字节代表该图片的高 后五个字节依次为：Bit depth、ColorType、Compression method、Filter method、Interlace method （可变）剩余四字节为该png的CRC检验码，由从IDCH到IHDR的十七位字节进行crc计算得到。","link":"/2019/09/17/PNG%E6%96%87%E4%BB%B6%E5%A4%B4/"},{"title":"Python中的regr()函数","text":"今天开始准备入门Python，入门的语法觉得挺简单的（有些编程语言基础）。 遇到个有趣的新类型转换函数repr()，官方文档的解释 repr(object) **Return a string containing a printable representation of an object. For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to eval(), otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object.A class can control what this function returns for its instances by defining a repr() method. 功能上和str()差不多，repr()对解释器更加友好，用此函数转化的字符串可以被eval()函数直接执行，而str()就不行。另外repr()函数转化出的浮点数精确度更高。 &gt;&gt;&gt;repr(1.0/6.0) ''0.16666666666666666' &gt;&gt;&gt; str(1.0/6.0) '0.166666666667'","link":"/2019/08/09/Python%E4%B8%AD%E7%9A%84regr-%E5%87%BD%E6%95%B0/"},{"title":"Windows下IDEA连接Linux的Hadoop2.7.7集群","text":"简单描述下如何在Windows下用IDEA连接Hadoop集群。 前提是有上述环境(Java8+IDEA+已经配置好的Hadoop集群) 下载安装Maven https://archive.apache.org/dist/maven/maven-3/ 我选择的是3.6.1版本。 配置环境变量及仓库 参考 http://maven.apache.org/install.html#windows-tips 先在环境变量中添加JAVA_HOME，如果路径是C:\\Program Files\\* 需要改为C:\\PROGRA~1\\*，因为路径中包含空格。 接着解压下载好的maven压缩包并记住这个路径，在Path变量中添加一条规则，即path\\to\\maven\\bin。然后打开cmd窗口，运行mvn -v。有正确的回显即为成功。 接下来在maven的文件夹中新建一个文件夹作为maven的仓库。修改path\\to\\maven\\conf\\settings.xml。我的配置如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;localRepository&gt;D:\\Maven\\repository&lt;/localRepository&gt; &lt;pluginGroups&gt; &lt;/pluginGroups&gt; &lt;proxies&gt; &lt;/proxies&gt; &lt;servers&gt; &lt;/servers&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;central repo&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;apache snapshots&lt;/mirrorOf&gt; &lt;name&gt;阿里云阿帕奇仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/apache-snapshots&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;name&gt;aliyunmaven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;MavenCentral&lt;/id&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;aliyunmavenApache&lt;/id&gt; &lt;url&gt;https://maven.aliyun.com/repository/apache-snapshots&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; &lt;/profiles&gt;&lt;/settings&gt; 打开IDEA的初始界面，选择Configure，settings-&gt;Builds -&gt; Build Tools找到Maven，将Maven home directory设置为path\\to\\maven，下面两个也是同理。 下载winutils.exe和hadoop.dll 首先将虚拟机中的hadoop.tar.gz压缩包复制到Windows中，解压到合适的位置，然后将path\\to\\hadoop\\bin和path\\to\\hadoop\\sbin添加到Path变量中，在cmd窗口运行hadoop。有正确的回显即为成功。 下载 https://github.com/cdarlint/winutils/ 的文件。解压找到你的hadoop版本包下的winutils和hadoop.dll，复制到path\\to\\hadoop\\bin目录下。 新建项目测试 在IDEA中新建一个maven项目，根据需求修改pom.xml。 测试wordcount的pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;wordcount&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-common --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.7.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-hdfs --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;2.7.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-mapreduce-client-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-mapreduce-client-core&lt;/artifactId&gt; &lt;version&gt;2.7.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-client --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.7.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-yarn-api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-yarn-api&lt;/artifactId&gt; &lt;version&gt;2.7.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jdk 使用idea 不需要配置这个--&gt; &lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;jdk.tools&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;jdk.tools&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;1.8&lt;/version&gt;--&gt; &lt;!--&lt;scope&gt;system&lt;/scope&gt;--&gt; &lt;!--&lt;systemPath&gt;${JAVA_HOME}/lib/tools.jar&lt;/systemPath&gt;--&gt; &lt;!--&lt;/dependency&gt;--&gt; &lt;/dependencies&gt; &lt;/project&gt; 将hadoop集群的core-site.xml、hdfs-site.xml、log4j.properties复制到src\\main\\resources下即可。 编写wordcount的代码，运行。 notice如果运行的时候出现Permission denied 打开项目环境中Edit Configurations，并在VMoption中输入： -DHADOOP_USER_NAME=user，user是你运行Hadoop的Linux的用户名。","link":"/2020/11/06/Windows%E4%B8%8BIDEA%E8%BF%9E%E6%8E%A5Linux%E7%9A%84Hadoop2-7-7%E9%9B%86%E7%BE%A4/"},{"title":"Ubuntu中Unable to acquire the dpkg frontend lock","text":"Ubuntu中Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend)的解决方案 环境 Ubuntu16.04-amd64在Ubuntu下进行apt操作时，提示E: Unable to acquire the dpkg frontend lock(/var/lib/dpkg/lock-frontend)。 出现这个问题的原因可能是：在Ubuntu系统的terminal下，用apt-get install 安装软件的时候，如果在未完成下载的情况下将terminal 强行关闭，再次运行apt-get install 命令安装软件时，出现如上错误。即有另一个程序正在占用apt-get install进程，由于它在运行时，会占用软件源更新时的系统锁（简称‘系统更新锁’），此时资源被锁。 解决办法第一种方法就是kill掉正在进行的apt进程，释放系统锁。 ​ ps -e | grep apt 在管理员权限下 ​ kill -9 如果上述操作完成后，仍然无法执行apt操作，则属于第二种情况。 进程列表中已经没有与apt,apt-get相关的进程在运行，但依然报错，在这种情况下，产生错误的根本原因是lock file。 loack file用于防止两个或多个进程使用相同的数据。 当运行apt或apt-commands时，它会在几个地方创建lock files。 当前一个apt命令未正确终止时，lock file未被删除，因此它们会阻止任何新的apt / apt-get命令实例，比如正在执行apt-get upgrade，在执行过程中直接ctrl+c取消了该操作，很有可能就会造成这种情况。要解决此问题，首先要删除lock file。 123lsof /var/lib/dpkg/locklsof /var/lib/apt/lists/locklsof /var/cache/apt/archives/lock 如果进行上述中的任意一个命令时有回显，就kill掉输出的进程。 然后在管理员权限下删除上述文件。 删除之后，重新配置一下dpkg 1sudo dpkg --configure -a 如果上述操作完成之后仍然报错： dpkg: error: dpkg frontend is locked by another process 我们还需要进行额外的操作： 找出正在锁定lock file的进程： ​ lsof /var/lib/dpkg/lock-frontend 如果有回显就kill掉输出的进程 ​ 删除lock file 并重新配置dpkg 12sudo rm /var/lib/dpkg/lock-frontendsudo dpkg --configure -a","link":"/2019/07/22/Ubuntu%E4%B8%ADUnable%20to%20acquire%20the%20dpkg%20frontend%20lock%20(varlibdpkglock-frontend)%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"XCTF  unserialize3","text":"XCTF unserialize3 原理 PHP反序列化漏洞：执行unserialize()时，先会调用__wakeup()。 当序列化字符串中属性值个数大于属性个数，就会导致反序列化异常，从而跳过__wakeup()。 目的 绕过常见的函数过滤机制 步骤 打开靶机 123456class xctf{ public $flag = '111'; public function __wakeup(){ exit('bad requests'); }?code= 可以看到题目信息是一个xctf类，包含一个public变量flag和php的魔术方法__wakeup()。将需要传递的序列化字符串赋值给code进行传递。 我们的目标是得到flag，而__wakeup()方法会在unserialize()执行前调用， __wabkeup()方法会执行exit()函数，故反序列化不可进行，那我们该如何绕过呢？ 具体细节：CVE-2016-7124 正常序列化 123456789class xctf{ public $flag = '111'; public function __wakeup(){ exit('bad requests'); }}$test = new xctf;$data = serialize($test);echo $data; 后的结果是 ​ 数据类型:属性名长度:”属性名”:属性个数;数据类型:属性值长度:”属性值” ​ O:4:”xctf”:1:{s:4:”flag”;s:3:”111”;} 如果直接传递给code就会执行exit()函数。 故我们需要绕过__wakeup()，将属性值设置为大于1的整型值即可导致反序列化异常。 传递?code=O:4:”xctf”:2:{s:4:”flag”;s:3:”111”;}参数即可getflag。","link":"/2019/08/05/XCTF%20%20unserialize3/"},{"title":"mysql的UDF函数","text":"定义 UDF函数是mysql给使用者提供的添加新函数的机制(User Define Function)。其有三种返回值，分别是 STRING 字符型(char *) INTEGER 整型(long long) REAL 实数型(double) 格式1234567CREATE [AGGREGATE] FUNCTION function_name RETURNS {STRING | INTEGER | REAL} SONAME '文件名'# [AGGREATE]是聚集函数的表示，系统定义的聚集函数有COUNT()、AVE()、MN()、MAX()、SUM()等# SONAME 'file' 表示这个函数从哪个文件里面引入，这个文件一般是动态链接库，Windows下是dll，Linux下是so，并且这个文件要在mysql的plugin目录下#删除自定义目录 DROP FUNCTION function_name notice: mysql版本如果在5.1以上，udf.dll文件必须放置在mysql安装目录下的lib\\plugin文件夹下。 mysql版本如果在5.1以下，udf.dll文件在Windows server 2003下放置于C:\\Windows\\system32目录，如果删除函数，udf文件必须还存在于plugin目录下。 如果mysql加载了udf.so文件中的某个函数，在没有删除这个函数前，把plugin目录下导入的udf.so文件利用rm命令删除了，那么这个导入的mysql函数就无法被删除。如果之后创建的函数名字和该函数冲突，mysql就不允许创建。","link":"/2019/09/06/mysql%E7%9A%84UDF%E5%87%BD%E6%95%B0/"},{"title":"Linux权限设置chmod","text":"chmod 参考自 https://www.linuxidc.com/Linux/2016-12/138322.htm Linux中设置权限，一般用chmod命令。 常用参数:chmod+x 执行权execute chmod+w 写权write chmod+r 读权read 设置权限后，目录下创建的文件拥有此目录所属组的权限 stickybit(只对文件有效)设置后，文件不可被删除 setgid(只对目录有效) 格式: chmod+参数 文件或目录名","link":"/2019/08/30/%E6%B5%85%E8%B0%88Linux%E6%9D%83%E9%99%90(chmod)/"},{"title":"浅谈PHP反序列化","text":"学习PHP序列化之前，首先需要了解PHP类。 最简单的类 12345678910111213141516class BOX{ private $length = 5; private $width = 5; function get_len(){ return $this-&gt;length; } function get_width(){ return $this-&gt;width; }}$box = new BOX();echo $box-&gt;get_len().PHP_EOL;echo $box-&gt;get_width.PHP_EOL; 123result:55 PHP序列化是什么 serialize() 将对象序列化为字符串 unseralize() 将序列化的字符串还原成对应的类 通过序列化与反序列化我们可以在PHP中进行对象的传递。本质上反序列化是没有危害的，但是如果用户对数据进行可控那就可以利用反序列化构造payload攻击。 实例1. 序列化123456789101112&lt;?php class test { private $flag = \"flag{233}\"; public $a = \"aaa\"; public $b = \"bbb\"; } $test = new test; $data = serialize($test); echo $data;?&gt; O:4:\"test\":3:{s:10:\"testflag\";s:9:\"flag{233}\";s:1:\"a\";s:3:\"aaa\";s:1:\"b\";s:3:\"bbb\";} O:&lt;class_name_length&gt;:\"&lt;class_name&gt;\":&lt;number_of_properties&gt;:{&lt;properties&gt;} 上面的怎么看呢？ O:4:\"test\"指Object(对象)4个字符:test :3对象属性个数为3 {}中为属性字符数：属性值 notice: 首先说明类中三种标识。 (1) public 公有变量，其序列化和理想中的一样。 (2) private 私有变量，只能其类使用，在属性前加上自己的”名字”。 (3) protected 受保护变量，和private相像，但是又有一些区别。 下面来看一个实例： 1234567891011121314151617181920212223&lt;?php class test { private $flag = 'Inactive'; protected $test = \"test\"; public $test1 = \"test1\"; public function set_flag($flag) { $this-&gt;flag = $flag; } public function get_flag($flag) { return $this-&gt;flag; } } $object = new test(); $object-&gt;set_flag('Active'); $data = serialize($object); file_put_contents(\"serialize.txt\", $data); ?&gt; 运行结果： 分析： testflag长度为8，序列化中却显示长度为10。 private变量会在其两侧加上空字节。 protected变量会在其前加*和一个空格。 public变量和普通变量一样。 2.反序列化1234567891011121314151617181920&lt;?phpclass test{ private $flag = 'Inactive'; protected $test = \"test\"; public $test1 = \"test1\"; public function set_flag($flag){ $this-&gt;flag = $flag; } public function get_flag(){ return $this-&gt;flag; }}$data = file_get_contents(\"serialize.txt\");$data = unserialize($data);echo $data-&gt;test1.\"&lt;br /&gt;\";echo $data-&gt;get_flag();?&gt; 运行结果： 特点 一般用于传递Object，Object对象无法直接传值，要先将其序列化为一段字符串，接收方收到后进行反序列化操作后还原为Object对象。 当序列化对象时，PHP在调用序列函数serialize()前检查是否存在__ wakeup()函数，如果存在则自动调用__ sleep()方法。在调用反序列化函数unserialize()前检查是否存在__ wakeup()函数，如果存在则自动调用__ wakeup()方法。 常见魔术方法123456789__construct()//创建对象时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__invoke() //当脚本尝试将对象调用为函数时触发 详见：https://segmentfault.com/a/1190000007250604 上文提及__ sleep() serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 __ wakeup() unserialize() 会检查是否存在一个 __ wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 实例1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass x1Drc1in{ public function __construct($ID,$sex,$age){ $this-&gt;ID = $ID; $this-&gt;sex = $sex; $this-&gt;age = $age; $this-&gt;info = sprintf(\"ID: %s, age: %d, sex: %s\", $this-&gt;ID, $this-&gt;sex, $this-&gt;age); } public function getInfo(){ echo $this-&gt;info . \"&lt;br /&gt;\"; } /* * serialize前调用 用于删选需要被反序列化存储的成员变量 * @return array [description] */ public function __sleep(){ echo __METHOD__ . \"&lt;br /&gt;\"; return ['ID', 'sex', 'age']; } /* * unserialize前调用 用于预先准备对象资源 */ public function __wakeup(){ echo __METHOD__ . \"&lt;br /&gt;\"; $this-&gt;info = sprintf(\"ID: %s, age: %d, sex: %s\", $this-&gt;ID, $this-&gt;sex, $this-&gt;age); }} $me = new x1Drc1in(\"TulnersXu\", 19, \"male\"); $me-&gt;getInfo(); echo \"&lt;br /&gt;\"; $temp = serialize($me); echo $temp . \"&lt;br /&gt;\"; echo \"&lt;br /&gt;\"; $me = unserialize($temp); $me-&gt;getInfo();?&gt; 运行结果： __ toString() __toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。 1234567891011121314151617181920&lt;?phpclass x1Drc1in{ public function __construct($ID,$sex,$age){ $this-&gt;ID = $ID; $this-&gt;sex = $sex; $this-&gt;age = $age; $this-&gt;info = sprintf(\"ID: %s, age: %d, sex: %s\", $this-&gt;ID, $this-&gt;sex, $this-&gt;age); } public function __toString(){ return $this-&gt;info; }}$me = new x1Drc1in('TulnersXu', 20, 'male');echo '__toString: ' . $me . '&lt;br /&gt;';?&gt; 运行结果：","link":"/2019/09/20/%E6%B5%85%E8%B0%88PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"浅谈base64编码、隐写","text":"base64 base64是如何编码的 字符对应的ASCII码转换成八位二进制 base64的基础单位是3 * 8bit的二进制，若是不够3 * 8bit则在后面添加0字节(padding)直至满足 3 * 8bit的二进制转换成4 * 6bit的二进制 4 * 6bit的二进制转换成十进制 对照base64表把十进制转换成字符即3个字符的字符串base64编码后会转成4个字符的base64编码 base64是如何解码的 检查base64编码后面有几个等于号 把字符串按照base64表转换成4 * 6的倍数位数二进制 *删除等于号的个数 * 8的bit* 按照6bit一组转换成字符 从解码步骤3我们可以看出我们可以控制等于号个数 * 2bit的字符 如图，我们可以在加粗的0的位子用二进制隐写。这样既不影响原文的还原，又不影响padding的删除，唯一的区别就是QQ==会变化，QkM=的M会变化，所以base64可以用于隐写。 base64表 base64加密后共有64个字符，6位的二进制数就足够表示base64表的字符了。 base64隐写利用编码和解码时的特性进行隐藏信息。例如A(01000001)补全(01000001 0000)按照base64进行编码变成(010000 010000)，导致之后会有两个=。在解码的时候去掉每个=对应的6个0同时去掉为了补全的4个0，解码时候解析(01000001)而不是(010000010000)。即可以利用上述的4个0来隐藏信息。 附上解隐写的脚本，原文链接 1234567891011121314151617181920212223242526272829303132def get_base64_diff_value(s1, s2): base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' res = 0 for i in x range(len(s1)): if s1[i] != s2[i]: #比较字符串差异的位数 return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): with open('stego.txt', 'rb') as f: file_lines = f.readlines()#先解密再加密是为了删除如果有base64隐写情况下被掺杂的1 bin_str = '' for line in file_lines: steg_line = line.replace('\\n', '') norm_line = line.replace('\\n', '').decode('base64').encode('base64').replace('\\n', '')#base64编码 diff = get_base64_diff_value(steg_line, norm_line) pads_num = steg_line.count('=') if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += '0' * pads_num * 2 res_str = '' for i in x range(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i+8], 2)) print res_strsolve_stego()","link":"/2019/09/12/%E6%B5%85%E8%B0%88base64%E7%BC%96%E7%A0%81%E3%80%81%E9%9A%90%E5%86%99/"},{"title":"浏览器解析流程和原理","text":"从输入 URL 到页面加载完成的过程中都发生了什么事情？ 具体参考 nwind的fex 这里目前只做简单阐述，知识水平未到。 从输入URL到浏览器接受发生了什么？ 输入URL 键盘or触摸屏 CPU内部处理 `移动设备中的 CPU 并不是一个单独的芯片，而是和 GPU 等芯片集成在一起，被称为 SoC（片上系统）。` CPU到操作系统内核 操作系统 GUI 到浏览器 浏览器如何向网卡发送数据？ 浏览器到浏览器内核 可以用session来控制 数据如何从本机网卡发送到服务器？ 从内核到网络适配器(Network Interface Card) 运营商网络内的路由 主干网间的传输 IDC 内网 服务器 CPU 服务器接收到数据后台会进行哪些处理？ 负载均衡 LVS 反向代理 Web Server中的处理 进入后端语言 Web框架 读取数据 服务器返回数据后浏览器如何处理？ 从二进制代码到字符 外链资源的加载 Javascript的执行 从字符到图片 跨平台2D绘制库 GPU合成 **这一部分可以参考：HTML页面渲染过程 浏览器如何将页面展现出来？ Framebuffer(帧缓存器) 从内存到显示器","link":"/2019/08/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86/"},{"title":"解决xampp用root进入phpmyadmin却提示无权用户的问题","text":"背景 重新装xampp之后，访问phpmyadmin，提示没有权限编辑用户 解决方案/* User for advanced features */ $cfg['Servers'][$i]['controluser'] = 'pma'; 改为 /* User for advanced features */ $cfg['Servers'][$i]['controluser'] = 'root'; $cfg['Servers'][$i]['controlpass'] = '';","link":"/2019/08/18/%E8%A7%A3%E5%86%B3xampp%E7%94%A8root%E8%BF%9B%E5%85%A5phpmyadmin%E5%8D%B4%E6%8F%90%E7%A4%BA%E6%97%A0%E6%9D%83%E7%94%A8%E6%88%B7%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"搜索算法","text":"- Wikipedia中的定义深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。[1](p603)这种算法不会根据图的结构等信息调整执行策略[来源请求]。 广度优先搜索算法（英语：Breadth-First Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。 C/C++语言描述DFS实现方法: 首先将根节点放入stack中。 从stack中取出第一个节点，并检验它是否为目标。 重复步骤2。 如果不存在未检测过的直接子节点。 重复步骤4。 若stack为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。 DFS的C模板大概如下: 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;int min = 99999999; // 定义最短路径int vis[100] = 0; // 标记数组，此路是否走过int a[100] = 0; // 要遍历的路void DFS(int x, int step){ if(x == 终点) // 到终点的决策 { if(step &lt; min) min = step; return; } if(a[x] == 1 &amp;&amp; vis[x] == 0) // 没在终点而且没有访问过的决策 { vis[x] = 1; // 标记为已走过 dfs(x + 1, step + 1); // 调用dfs vis[x] = 0 // 回溯时复位 } return;}int main(){ // 输入参数，初始化 ... // 设置起点并将其标记为已访问 vis[startx] = 1; // 调用函数 dfs(startx, 0); // 输出结果 printf(\"%d\\n\", min); return 0;} BFS实现方法 首先将根节点放入队列中。 从队列中取出第一个节点，并检验它是否为目标。 如果找到目标，则结束搜索并回传结果。 否则将它所有尚未检验过的直接子节点加入队列中。 若队列为空，表示整张图都检查过了——亦即图中没有欲搜索的目标。结束搜索并回传“找不到目标”。 重复步骤2。 BFS的C++模板大概如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bit/stdc++.h&gt;using namespace std;int vis[100] = 0; // 标记数组，此路是否走过int a[100] = 0; // 要遍历的路int flag = 0;struct point{ int x; int step;};queue&lt;note&gt; r;int main(){ // 输入参数，初始化 ... point start; start.x = startx; start.step = 0; r.push(start); vis[startx] = 1; // 设置起点并将其标记为已访问 while(!r.empty()) { int x = r.front().x; if(x == 终点) // 到终点的决策 { flag = 1; printf(\"%d\\n\", r.front().step); break; } if(a[x] == 1 &amp;&amp; vis[x] == 0) // 没在终点而且没有访问过的决策 { // 入队 point temp; temp.x = x; temp.step = r.front().step + 1; r.push(temp); v[x] = 1; } r.pop(); // 拓展完成之后首节点出队 } if(flag == 0) printf(\"NO Answer.\"); return 0;} 例题待更新…","link":"/2020/10/20/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"title":"HTBH","text":"- 引用自：hacker-howto 态度1. 世界充满着有趣的等待被解决的问题在解决一个问题之后应该有一种兴奋的感觉。 2. 没有一个问题被解决两次这不意味着把现有的已存在的都看作不可推翻的，也不是一个问题只有一种解决方案。通常，通过研究解决方案的第一个环节，我们可以了解到很多以前不知道的问题。相信我们可以做得更好，不应重复造轮子。 3. 无聊和单调的事是让人不舒服的这仿佛是个悖论，因为这不意味着做无聊、单调的事情是不允许的。在锻炼、提升自己解决问题的能力的时候，这种“无聊单调的事”是会存在的。尽可能让重复的工作自动化。 4. 自由5. 态度不能代表能力成为一个hacker将需要智慧、实践、奉献和努力工作。保持质疑、尊重每一种能力，能熟练掌握很少人能掌握的高要求技能是特别好的，最好能熟练掌握包括智力敏锐、技艺和注意力集中的高要求的技能。 基础技能1. 学习如何编程Python、Ｃ/C++、Perl、LISP（and Go？），相对来说重要，这些语言代表不同的编程方法，每一种都会用有价值的方式教育自己。 最重要的是：Reading code和Writing code。多读多写重复重复…… 参考 Teach Yourself Programming in Ten Years 中的“recipe for programming success”部分 保持兴趣 写代码 Learning by doing 与其他程序员交流 与其他程序员合作或跟随写一个项目 学习一些编程语言 懂得计算机组成原理的知识 参与到语言标准化工作中 尽可能摆脱语言标准 2. 寻找一个开源的Unix系统并学习使用、运行它学习Unix，可以看 The Loginataka 同时需要 The Art Of Unix Programming。 3. 学习如何使用WWW和书写HTMLThe HTML Hell Page 4. 学习实用英语可做的工作1. 写开源软件2. 帮助测试和debug开源软件3. 发布有用的信息4. 帮助保持基础工作5. 服务于hacker文化本身Other ResourcesPaul Graham has written an essay called Great Hackers, and another on Undergraduation, in which he speaks much wisdom. Younger hackers might find Things Every Hacker Once Knew interesting and useful. I have also written A Brief History Of Hackerdom. I have written a paper, The Cathedral and the Bazaar, which explains a lot about how the Linux and open-source cultures work. I have addressed this topic even more directly in its sequel Homesteading the Noosphere. Rick Moen has written an excellent document on how to run a Linux user group. Rick Moen and I have collaborated on another document on How To Ask Smart Questions. This will help you seek assistance in a way that makes it more likely that you will actually get it. If you need instruction in the basics of how personal computers, Unix, and the Internet work, see The Unix and Internet Fundamentals HOWTO. When you release software or write patches for software, try to follow the guidelines in the Software Release Practice HOWTO. If you enjoyed the Zen poem, you might also like Rootless Root: The Unix Koans of Master Foo. Frequently Asked Questions Q: How do I tell if I am already a hacker? Q: Will you teach me how to hack? Q: How can I get started, then? Q: When do you have to start? Is it too late for me to learn? Q: How long will it take me to learn to hack? Q: Is Visual Basic a good language to start with? Q: Would you help me to crack a system, or teach me how to crack? Q: How can I get the password for someone else’s account? Q: How can I break into/read/monitor someone else’s email? Q: How can I steal channel op privileges on IRC? Q: I’ve been cracked. Will you help me fend off further attacks? Q: I’m having problems with my Windows software. Will you help me? Q: Where can I find some real hackers to talk with? Q: Can you recommend useful books about hacking-related subjects? Q: Do I need to be good at math to become a hacker? Q: What language should I learn first? Q: What kind of hardware do I need? Q: I want to contribute. Can you help me pick a problem to work on? Q: Do I need to hate and bash Microsoft? Q: But won’t open-source software leave programmers unable to make a living? Q: Where can I get a free Unix? Q: How do I tell if I am already a hacker? A: Ask yourself the following three questions:Do you speak code, fluently?Do you identify with the goals and values of the hacker community?Has a well-established member of the hacker community ever called you a hacker?If you can answer yes to all three of these questions, you are already a hacker. No two alone are sufficient.The first test is about skills. You probably pass it if you have the minimum technical skills described earlier in this document. You blow right through it if you have had a substantial amount of code accepted by an open-source development project.The second test is about attitude. If the five principles of the hacker mindset seemed obvious to you, more like a description of the way you already live than anything novel, you are already halfway to passing it. That’s the inward half; the other, outward half is the degree to which you identify with the hacker community’s long-term projects.Here is an incomplete but indicative list of some of those projects: Does it matter to you that Linux improve and spread? Are you passionate about software freedom? Hostile to monopolies? Do you act on the belief that computers can be instruments of empowerment that make the world a richer and more humane place?But a note of caution is in order here. The hacker community has some specific, primarily defensive political interests — two of them are defending free-speech rights and fending off “intellectual-property” power grabs that would make open source illegal. Some of those long-term projects are civil-liberties organizations like the Electronic Frontier Foundation, and the outward attitude properly includes support of them. But beyond that, most hackers view attempts to systematize the hacker attitude into an explicit political program with suspicion; we’ve learned, the hard way, that these attempts are divisive and distracting. If someone tries to recruit you to march on your capitol in the name of the hacker attitude, they’ve missed the point. The right response is probably “Shut up and show them the code.”The third test has a tricky element of recursiveness about it. I observed in the section called “What Is a Hacker?” that being a hacker is partly a matter of belonging to a particular subculture or social network with a shared history, an inside and an outside. In the far past, hackers were a much less cohesive and self-aware group than they are today. But the importance of the social-network aspect has increased over the last thirty years as the Internet has made connections with the core of the hacker subculture easier to develop and maintain. One easy behavioral index of the change is that, in this century, we have our own T-shirts.Sociologists, who study networks like those of the hacker culture under the general rubric of “invisible colleges”, have noted that one characteristic of such networks is that they have gatekeepers — core members with the social authority to endorse new members into the network. Because the “invisible college” that is hacker culture is a loose and informal one, the role of gatekeeper is informal too. But one thing that all hackers understand in their bones is that not every hacker is a gatekeeper. Gatekeepers have to have a certain degree of seniority and accomplishment before they can bestow the title. How much is hard to quantify, but every hacker knows it when they see it. Q: Will you teach me how to hack? A: Since first publishing this page, I’ve gotten several requests a week (often several a day) from people to “teach me all about hacking”. Unfortunately, I don’t have the time or energy to do this; my own hacking projects, and working as an open-source advocate, take up 110% of my time.Even if I did, hacking is an attitude and skill you basically have to teach yourself. You’ll find that while real hackers want to help you, they won’t respect you if you beg to be spoon-fed everything they know.Learn a few things first. Show that you’re trying, that you’re capable of learning on your own. Then go to the hackers you meet with specific questions.If you do email a hacker asking for advice, here are two things to know up front. First, we’ve found that people who are lazy or careless in their writing are usually too lazy and careless in their thinking to make good hackers — so take care to spell correctly, and use good grammar and punctuation, otherwise you’ll probably be ignored. Secondly, don’t dare ask for a reply to an ISP account that’s different from the account you’re sending from; we find people who do that are usually thieves using stolen accounts, and we have no interest in rewarding or assisting thievery. Q: How can I get started, then? A: The best way for you to get started would probably be to go to a LUG (Linux user group) meeting. You can find such groups on the LDP General Linux Information Page; there is probably one near you, possibly associated with a college or university. LUG members will probably give you a Linux if you ask, and will certainly help you install one and get started.Your next step (and your first step if you can’t find a LUG nearby) should be to find an open-source project that interests you. Start reading code and reviewing bugs. Learn to contribute, and work your way in.The only way in is by working to improve your skills. If you ask me personally for advice on how to get started, I will tell you these exact same things, because I don’t have any magic shortcuts for you. I will also mentally write you off as a probable loser - because if you lacked the stamina to read this FAQ and the intelligence to understand from it that the only way in is by working to improve your skills, you’re hopeless.Another interesting possibility is to go visit a hackerspace. There is a burgeoning movement of people creating physical locations - maker’s clubs - where they can hang out to work on hardware and software projects together, or work solo in a cogenial atmosphere. Hackerspaces often collect tools and specialized equipment that would be too expensive or logistically inconvenient for individuals to own. Hackerspaces are easy to find on the Internet; one may be located near you. Q: When do you have to start? Is it too late for me to learn? A: Any age at which you are motivated to start is a good age. Most people seem to get interested between ages 15 and 20, but I know of exceptions in both directions. Q: How long will it take me to learn to hack? A: That depends on how talented you are and how hard you work at it. Most people who try can acquire a respectable skill set in eighteen months to two years, if they concentrate. Don’t think it ends there, though; in hacking (as in many other fields) it takes about ten years to achieve mastery. And if you are a real hacker, you will spend the rest of your life learning and perfecting your craft. Q: Is Visual Basic a good language to start with? A: If you’re asking this question, it almost certainly means you’re thinking about trying to hack under Microsoft Windows. This is a bad idea in itself. When I compared trying to learn to hack under Windows to trying to learn to dance while wearing a body cast, I wasn’t kidding. Don’t go there. It’s ugly, and it never stops being ugly.There is a specific problem with Visual Basic; mainly that it’s not portable. Though there is a prototype open-source implementations of Visual Basic, the applicable ECMA standards don’t cover more than a small set of its programming interfaces. On Windows most of its library support is proprietary to a single vendor (Microsoft); if you aren’t extremely careful about which features you use — more careful than any newbie is really capable of being — you’ll end up locked into only those platforms Microsoft chooses to support. If you’re starting on a Unix, much better languages with better libraries are available. Python, for example.Also, like other Basics, Visual Basic is a poorly-designed language that will teach you bad programming habits. No, don’t ask me to describe them in detail; that explanation would fill a book. Learn a well-designed language instead.One of those bad habits is becoming dependent on a single vendor’s libraries, widgets, and development tools. In general, any language that isn’t fully supported under at least Linux or one of the BSDs, and/or at least three different vendors’ operating systems, is a poor one to learn to hack in. Q: Would you help me to crack a system, or teach me how to crack? A: No. Anyone who can still ask such a question after reading this FAQ is too stupid to be educable even if I had the time for tutoring. Any emailed requests of this kind that I get will be ignored or answered with extreme rudeness. Q: How can I get the password for someone else’s account? A: This is cracking. Go away, idiot. Q: How can I break into/read/monitor someone else’s email? A: This is cracking. Get lost, moron. Q: How can I steal channel op privileges on IRC? A: This is cracking. Begone, cretin. Q: I’ve been cracked. Will you help me fend off further attacks? A: No. Every time I’ve been asked this question so far, it’s been from some poor sap running Microsoft Windows. It is not possible to effectively secure Windows systems against crack attacks; the code and architecture simply have too many flaws, which makes securing Windows like trying to bail out a boat with a sieve. The only reliable prevention starts with switching to Linux or some other operating system that is designed to at least be capable of security. Q: I’m having problems with my Windows software. Will you help me? A: Yes. Go to a DOS prompt and type “format c:”. Any problems you are experiencing will cease within a few minutes. Q: Where can I find some real hackers to talk with? A: The best way is to find a Unix or Linux user’s group local to you and go to their meetings (you can find links to several lists of user groups on the LDP site at ibiblio).(I used to say here that you wouldn’t find any real hackers on IRC, but I’m given to understand this is changing. Apparently some real hacker communities, attached to things like GIMP and Perl, have IRC channels now.) Q: Can you recommend useful books about hacking-related subjects? A: I maintain a Linux Reading List HOWTO that you may find helpful. The Loginataka may also be interesting.For an introduction to Python, see the tutorial on the Python site. Q: Do I need to be good at math to become a hacker? A: No. Hacking uses very little formal mathematics or arithmetic. In particular, you won’t usually need trigonometry, calculus or analysis (there are exceptions to this in a handful of specific application areas like 3-D computer graphics). Knowing some formal logic and Boolean algebra is good. Some grounding in finite mathematics (including finite-set theory, combinatorics, and graph theory) can be helpful.Much more importantly: you need to be able to think logically and follow chains of exact reasoning, the way mathematicians do. While the content of most mathematics won’t help you, you will need the discipline and intelligence to handle mathematics. If you lack the intelligence, there is little hope for you as a hacker; if you lack the discipline, you’d better grow it.I think a good way to find out if you have what it takes is to pick up a copy of Raymond Smullyan’s book What Is The Name Of This Book?. Smullyan’s playful logical conundrums are very much in the hacker spirit. Being able to solve them is a good sign; enjoying solving them is an even better one. Q: What language should I learn first? A: HTML if you don’t already know it. There are a lot of glossy, hype-intensive bad HTML books out there, and distressingly few good ones. The one I like best is HTML: The Definitive Guide.But HTML is not a full programming language. When you’re ready to start programming, I would recommend starting with Python. You will hear a lot of people recommending Perl, but it’s harder to learn and (in my opinion) less well designed.C is really important, but it’s also much more difficult than either Python or Perl. Don’t try to learn it first.Windows users, do not settle for Visual Basic. It will teach you bad habits, and it’s not portable off Windows. Avoid. Q: What kind of hardware do I need? A: It used to be that personal computers were rather underpowered and memory-poor, enough so that they placed artificial limits on a hacker’s learning process. This stopped being true in the mid-1990s; any machine from an Intel 486DX50 up is more than powerful enough for development work, X, and Internet communications, and the smallest disks you can buy today are plenty big enough.The important thing in choosing a machine on which to learn is whether its hardware is Linux-compatible (or BSD-compatible, should you choose to go that route). Again, this will be true for almost all modern machines. The only really sticky areas are modems and wireless cards; some machines have Windows-specific hardware that won’t work with Linux.There’s a FAQ on hardware compatibility; the latest version is here. Q: I want to contribute. Can you help me pick a problem to work on? A: No, because I don’t know your talents or interests. You have to be self-motivated or you won’t stick, which is why having other people choose your direction almost never works. Q: Do I need to hate and bash Microsoft? A: No, you don’t. Not that Microsoft isn’t loathsome, but there was a hacker culture long before Microsoft and there will still be one long after Microsoft is history. Any energy you spend hating Microsoft would be better spent on loving your craft. Write good code — that will bash Microsoft quite sufficiently without polluting your karma. Q: But won’t open-source software leave programmers unable to make a living? A: This seems unlikely — so far, the open-source software industry seems to be creating jobs rather than taking them away. If having a program written is a net economic gain over not having it written, a programmer will get paid whether or not the program is going to be open-source after it’s done. And, no matter how much “free” software gets written, there always seems to be more demand for new and customized applications. I’ve written more about this at the Open Source pages. Q: Where can I get a free Unix? A: If you don’t have a Unix installed on your machine yet, elsewhere on this page I include pointers to where to get the most commonly used free Unix. To be a hacker you need motivation and initiative and the ability to educate yourself. Start now… 一些论坛和博客linux linux command linux die matt might","link":"/2022/05/28/HTBH/"}],"tags":[{"name":"Writeup","slug":"Writeup","link":"/tags/Writeup/"},{"name":"Bigdata","slug":"Bigdata","link":"/tags/Bigdata/"},{"name":"C++ Primer Plus","slug":"C-Primer-Plus","link":"/tags/C-Primer-Plus/"},{"name":"CTFd平台搭建","slug":"CTFd平台搭建","link":"/tags/CTFd%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"},{"name":"visualize","slug":"visualize","link":"/tags/visualize/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"HTTP协议","slug":"HTTP协议","link":"/tags/HTTP%E5%8D%8F%E8%AE%AE/"},{"name":"二战提醒","slug":"二战提醒","link":"/tags/%E4%BA%8C%E6%88%98%E6%8F%90%E9%86%92/"},{"name":"C Data Struct","slug":"C-Data-Struct","link":"/tags/C-Data-Struct/"},{"name":"文件头","slug":"文件头","link":"/tags/%E6%96%87%E4%BB%B6%E5%A4%B4/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Hadoop","slug":"Hadoop","link":"/tags/Hadoop/"},{"name":"Error","slug":"Error","link":"/tags/Error/"},{"name":"序列化","slug":"序列化","link":"/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"UDF函数","slug":"UDF函数","link":"/tags/UDF%E5%87%BD%E6%95%B0/"},{"name":"权限设置","slug":"权限设置","link":"/tags/%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/"},{"name":"反序列化","slug":"反序列化","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"Base64","slug":"Base64","link":"/tags/Base64/"},{"name":"浏览器原理","slug":"浏览器原理","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"xampp, 权限","slug":"xampp-权限","link":"/tags/xampp-%E6%9D%83%E9%99%90/"},{"name":"HTBH","slug":"HTBH","link":"/tags/HTBH/"}],"categories":[{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"Bigdata","slug":"Bigdata","link":"/categories/Bigdata/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"CTFd","slug":"CTFd","link":"/categories/CTFd/"},{"name":"Data analysis","slug":"Data-analysis","link":"/categories/Data-analysis/"},{"name":"Problem","slug":"Problem","link":"/categories/Problem/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"plan","slug":"plan","link":"/categories/plan/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"密码学","slug":"密码学","link":"/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"阅读笔记","slug":"阅读笔记","link":"/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}]}